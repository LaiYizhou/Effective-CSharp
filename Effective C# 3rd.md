# 第一章 C\#语言的编程习惯



## 1. 优先使用隐式类型的局部变量

- 隐式类型 `var`
- 是为了支持 **匿名类型** 而引入
- 使用 `var` 可以让开发者把注意力更多地放在命名上
- 使用了 `var` 不代表这是动态变量，只是让编译器来判断变量类型，也就是说，变量类型在编译的时候已经确定了
- 如果开发者（包括未来的自己）不知道变量类型则无法理解代码含义，则此时不要使用 `var`
- 一些简单的值类型，比如int、float等，建议不使用 `var`



## 2. 考虑使用 *readonly* 代替 *const*

- readonly 是 **运行常量**； const 是 **编译常量**
- **编译常量** 可以视为一种“替换”，更快；但是，**运行常量** 更灵活
- 注意：编译常量是不允许 `new` 操作符来初始化的
- readonly 是“实例级别”的常量，也就是说，一个类初始化成不同的实例，可能其中的readonly常量会不同
- const 是一个“静态常量”



## 3. 优先考虑 *is* 或 *as* 运算符，尽量少用强制类型转换

- 更安全，而且在运行的时候也更高效
- 而且一般情况下，不会因为类型转换而构建新的对象

- `is` 运算符，是支持多态的



## 4. 用内插字符串取代 *string.Format()*

- string.Format() 格式

  ```c#
   string info = string.Format("My name is {0}, And My Age is {1}", "Bob", 10);
  ```

- 内插字符串（Interpolated String）格式，以 `$` 开头

  ```c#
   string info = $"My name is {"An"}, And My Age is {10}";
  ```

- 请注意 **格式说明符** 的冒号 和 **条件表达式** 的冒号 混淆的问题



## 5. 用 *FormattableString* 取代专门为特定区域而写的字符串



## 6. 不要用表示符号名称的硬字符串来调用API

- C#6.0中，新的运算符 `nameof`



## 7. 用委托来表示回调

- 回调函数

  简单来说，就是一个函数，比如 `GetSum()` 不直接调用，而是把它当做一个参数，传到另一个函数里去，然后，在那个一个函数里调用。这时，`GetSum()` 被称为 **回调函数**

- 委托

  C#中的委托，都是多播委托（multicast delegate）

  所以，需要注意：

  - 第一，众多目标函数中有一个抛出异常，整个调用链就会中断
  - 第二，程序会把最后执行的那个目标函数的返回值作为整个委托的返回值



## 8. 用 *null条件运算符* 调用事件处理程序

- null条件运算符 `?.`

- 调用空事件会抛出异常，同时，又考虑到线程安全问题

  ```c#
  if(Update != null)
  {
      Update();
  }
  ```

  即使这样，也不是线程安全的

  所以，可以改成

  ```c#
  Update?.Invoke();
  ```


## 9. 尽量避免装箱和拆箱操作

- 比如

  ```c#
  number.ToString();
  ```

  有时候不写也是OK的，但是建议写。

  不写就意味着：编译器隐式地进行了装箱操作

- 再比如，ArrayList



## 10. 在新基类与现有子类冲突时才使用 `new` 修饰符

- 一般情况下是，基类有一个函数名，然后子类也想有一个相同的，于是使用 `new` 修饰符

  这种情况下使用 `new` 修饰符，其实是不可取的

- 应该是：**在基类中加了一个函数，结果和子类冲突了**

  （至于为什么加，可能是主程加的，也可能是第三方SDK更新的）

  只有在这种情况下，才建议使用 `new` 修饰符

- 当然，有更好的办法，就是：修改一下子类的函数名

  **修改子类的函数名，虽然在短期内需要花一点时间，但是从长远看，效果比使用 `new` 修饰符好**



# 第二章 .NET的资源管理


















